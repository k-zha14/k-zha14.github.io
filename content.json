{"pages":[],"posts":[{"title":"Games101: Computer Graphics Summary","text":"课程主要资料 课程录播-Video Lecture 课件-PowerPoints 课程笔记-Lecture Notes 课后作业-Homework 推荐教材及读物 (Tiger book) Lecture Notes Lec 01 - Overview 计算机图形学概述+专业名词解释 Lec 02 - Linear Algebra 必备的向量和线性代数知识 Lec 03 - Transformations 基础的2D变换和齐次坐标系 专业名词Projection - 投影； Scale - 缩放; Homogenous Coordinates - 齐次坐标； Rasterization - 光栅化；meshing - 渲染； Jaggies - 锯齿； Homework Hw0 - 配置环境 HW1 - 旋转、透视投影矩阵 Hw2 - Rasterization(光栅化)","link":"/2020/12/02/Games101-Computer-Graphics-Summary/"},{"title":"Games101: Computer Graphics-Week 1","text":"1. Why study Computer Graphics? Applications: Video Games, Movies, Animations, Design, Visualization, VR&amp;AR, Digital Illustration, Simulation, GUI, Typography Fundamental Intellectual Challenges Creates and interacts with realistic virtual world Requires understanding of all aspects of physical world New computing methods, displays, technologies Technical Challenges Math of (perspective) projections, curves, surfaces Physics of lighting and shading Representing / operating shapes in 3D Animation / simulation 3D graphics software programming and hardware 2. Course Topics (mainly 4 parts) Rasterization(光栅化) 将3D 物体投影到并展示到屏幕上 Curves and Meshes How to represent geometry in Computer Graphics. Ray Tracing(光线追踪) Shoot rays from camera though each pixel , Calculate intersection and shading, and rays will continue bounce till they hit light sources. Animation / Simulation Key frame Animation Mass-spring System 3. Graphics IDE的推荐： 推荐：VS，VSC 不推荐：CLion, Eclipse / Sublime, Vi/Vim, Emacs 理由：大型项目，插件齐全节省时间，没必要和效率过不去","link":"/2020/12/02/Games101-Computer-Graphics-Week-1/"},{"title":"Games101: Computer Graphics-Week 2","text":"1. Vector-向量课程中所有的向量默认是列向量形式，转置后为行向量； 1.1 Dot Production在图形学中，核心的作用有三个： 1）求出两个向量的夹角，余弦值； 2）求出向量a在向量b上的投影，以及获得副产物法向量： 3）判断不同向量的前后关系（余弦相似度）： 这里的前后关系可以理解为**同向与反向**，而且这种关系应用于渲染的光线的金属高光反射参数。 1.2 Cross Production in Graphics 默认使用右手螺旋定则，与OPENGL一致，坐标系为右手系； DirectX默认为左手系，即满足：$$\\vec x \\times \\vec y = -\\vec z$$ 在图形学中，叉乘主要有两个用处： 1）判断向量的左右 从右下角的示例可以看出，这是一个标准的右手系，有：$$\\vec b \\times \\vec a &lt;0, \\vec a \\times \\vec b &gt;0$$这时，对应关系为b在a的左侧，a在b的右侧。 2）判断点是否在图形内部 如何判断P在ABC的内部？ 利用起那一步的左右性进行判断，以A-&gt;B-&gt;C顺序：$$\\vec {AB} \\times \\vec {AP} &gt;0, \\vec {BC} \\times \\vec {BP}&gt;0, \\vec {CA} \\times \\vec {CP} &gt;0$$可以看到，无论对于哪条边，点P始终在该边的左侧，因此P点在ABC中； 进一步，通用的结论是，无论ABC是顺时针，还是逆时针，若P点在图形内，则必然各边叉乘结果同号；反正，至少有一条边结果不同号则在外。 在边上的点，叉乘为0，corner case，是否包含该点由自己定义。 2. Matrix-矩阵基础知识，矩阵的乘法解释挺有意思，贴在下面： 以及如何将向量的点乘和叉乘写成矩阵形式：","link":"/2020/12/02/Games101-Computer-Graphics-Week-2/"},{"title":"Games101: Computer Graphics-Week 3","text":"1. Transformation-变换 Modelling-模型变换 游戏中场景的变化； 机器人跳舞（姿态变化）； 物体相互作用发生形变和缩放； 光栅化成像，从3D到2D的projection（投影） Viewing-视角变换 同一个对象，主摄影视角进行变换产生不同的光栅化视角； 2. 2D Transformation作为3维变换的基础，从2D变换讲起，核心是：将变换操作与矩阵操作联系起来！ Attention: 这些变换均可以由一个变换矩阵表征，所以统称为线性变换（Linear Transforms）； 下面的x, y为图上任意一点的坐标； 下面的变换默认是对基向量（单位长度）进行变换的； 2.1 Scale 等比缩放 非等比缩放 2.2 Reflection-翻转以相对y轴进行镜像翻转为例，给出Reflection Matrix 2.3 Shear-切变 物体具有一定的弹性，可以沿某个方向发生一定的形变。 2.4 Rotate-旋转 2D 旋转，默认逆时针以原点作为中心进行旋转 旋转矩阵的推导和证明： 法1：可以在旋转坐标系中，任选两个点求解映射变换表达式； 法2： 可以取两个特殊点(1,0)和(0,1)以逆时针旋转θ角度，根据旋转前后的坐标，列出4个方程，求解旋转矩阵的未知数； 2.5 Inverse Transform逆变换矩阵就是原变换矩阵的逆矩阵。 Homogeneous Coordinates(齐次坐标) 上述的都是线性变换，可以表示为变换矩阵相乘的形式； Why引入齐次坐标？ 当发生平移变换(Translation，就是翻译这个单词)时，无法再使用上面的变换矩阵相乘的形式进行表征，只能写作**仿射映射(Affline Map)**形式： 仿射变换 = 线性变换 + 平移（即便在齐次坐标中也是如此，先线性再平移） 由于这种形式不满足上面的方程形式，所不是线性变换。 为了能用上面的矩阵乘法形式统一表征变换操作，引入齐次坐标系的概念。 齐次坐标的定义 点和向量的表示 2D Point: $(x, y, 1)^T$ 2D Vector: $ (x, y, 0)^T$ 平移变换表示 为什么点的增加列为1，而向量的增加列为0？ 首先，向量具有平移不变性，也就是说平移操作不应该影响向量； 其次，更深层次，这个符合物理定义： 在扩充定义的补充下，对于$ w \\neq 1$的点，都进行归一化操作，此时point+point实际结果就是中点。 综上，可以用齐次坐标下的线性变换形式表示二维情况下的仿射变换时，齐次坐标的最后一行一定为$ (0, 0, 1) $。（注意限定条件，其他情况下，最后一行有意义）","link":"/2020/12/09/Games101-Computer-Graphics-Week-3/"},{"title":"Games101: Computer Graphics-Week 4","text":"Recap and supplement 对于旋转变换，逆时针旋转θ角度和顺时针旋转θ角度的矩阵恰好为正交矩阵，此时矩阵的转置和矩阵的逆相等。 为了统一平移变换和线性变换的书写形式，引入齐次坐标的概念，实质是增加一个维度； 3D TransformationsOn homogeneous coordinates, 3D points/vectors can be described as : 3D point = $ (x, y, z, 1)^T$ 3D vector = $ (x, y, z, 0)^T $ In general, if $ (x, y, z, w)^T $ ($ w \\neq 0$ and $w \\neq 1$), which refers the same point $(x/w, y/w, z/w, 1)^T $ Scale Translation Rotate先从绕某一固定轴进行旋转，更普遍的旋转是这三种旋转矩阵的连乘组合 1. 怎么理解绕y轴旋转矩阵是反向的？ 从坐标系可以看出：$ \\vec{z} \\times \\vec{x} = \\vec{y} $，而这里的坐标向量是按xyz组织的，$\\vec{x}$与$\\vec{z}$的顺序与坐标系规定恰好相反，所以方向是反的。 2. Rodrigues’ Rotation Formula(罗德里格斯旋转公式) 给定旋转角度α和旋转参考轴 $\\vec{n}$ (默认旋转轴的起点是原点)，那么有如下公式： 公式核心是将旋转分解到 $ \\vec{x}, \\vec{y}, \\vec{z} $ 三个方向，然后进行旋转。公式$R(n, \\alpha)$ 返回的是一个变换矩阵，上面的变换矩阵$ N $ 可以理解为两个向量做叉乘时，第一个向量可以改写为矩阵形式，进行左乘。 3. 在Rodrigues公式下，如何绕任意轴进行旋转？ 先平移到原点，再套用公式进行旋转，然后再平移回旋转点。 略去概念：四元数，其引入目标是解决，旋转矩阵不能直接作线性插值。E.g. 一个旋转$\\alpha$角度的矩阵A和旋转$\\beta$角度的矩阵B，两矩阵相加除以2所得到的的矩阵不等于旋转$ (\\alpha + \\beta)/2$的矩阵，不是线性插值。 Viewing(观测) transformation核心将三维图形变换到二维，两要素：三维场景+给定观察点； 类比拍照，给出View的三个步骤： (Model transformation) Find a good place and arrange people - 设置好被摄影物体； (View transformation) Find a good “angle” to put the camera - 找好相机角度； (Projection transformation) Cheese! - 拍照； 上述三步合称为MVP变换，not means Most Valuable Players，下面主要介绍View transformation。 View(视图)/Camera transformation How to perform view transformation? 备注： 位置向量$ \\vec{e} $ ，观测方向 $ \\vec{g}$，向上方向$ \\vec{t}$(相机本身可以围绕观测方向旋转，因此需要指明方向，固定这个自由度) 考虑相对性，只有当物体和相机发生相对位移，摄像机的内容才会发生变化。因此，为了方便起见，这里惯例设定：相机放置在坐标系原点$(0, 0, 0)$，向上方向是沿$\\vec{y}$，摄像机方向是$\\vec{-z}$。 综上，核心是：将摄影机平移放置到原点，然后再将坐标系的不同轴旋转到标准的 $\\vec{x}, \\vec{y}, \\vec{z}$ 方向： 注意：这里的旋转矩阵本身很难求，但可以逆向思考求解，以$\\vec{x}=(1,0,0,0)^{T}$为例，将其旋转到$\\vec{g}\\times\\vec{t}$方向，很容易写出$R_{view}^{-1}$的第一列，即$\\vec{g}\\times\\vec{t}$在$\\vec{x}, \\vec{y}, \\vec{z}$ 的分解向量，然后对$R_{view}$就是$R_{view}^{-1}$的转置！(旋转矩阵是正交矩阵的性质！！！) Projection(投影) transformation 3D -&gt; 2D； 分为正交投影和透视投影，区别在于投影图是否考虑了透视关系-近大远小； 透视投影会汇聚于1个点，而正交投影可以认为相机在无限远处。 Orthographic projection-正交投影理论步骤： 将相机(观测点)摆放到原点，方向设为惯例：看向$-\\vec{Z}$，上方向为$\\vec{Y}$; 物体点的坐标直接丢掉Y轴就可以了(这里要考虑前后重叠的问题)； 进行translate，再scale将投影放缩到$[-1,1]^2$(这里的上标2表示x和轴均为此范围) 实际步骤： translate + scale 为什么是[f,n]而不是[n,f]? 注意相机观测是 $-y$方向，远点f的值小于近点n的值。 给出变换矩阵$M_{ortho}$： 从矩阵可以看出，先平移到立方体中心，然后再缩放。 Perspective projection-透视投影透视投影可以等效为两步： 先将远点f在本平面内挤压，$M_{persp-&gt;ortho}$ 如图所示，将一个frustum(截头锥体)转换为Cuboid(立方体) 再进行正交投影，$M_{ortho}$ 因此，可以有两个结论： 近平面n上的点应不受$M_{persp-&gt;ortho}$操作影响，远平面f上的点只在本平面内压缩，即点坐标$z$值布标； 注意，这里并没有限制n和f之间的点在挤压操作后，z坐标不变！ 所以，核心问题转为如何求$M_{persp-&gt;ortho}$？ 由透视关系，相似性原理可知： 所以，对于任意点坐标(不局限n和f平面)：$(x,y,z,1)$有： 可知（待求z坐标的变换行向量）： 引入n平面和f平面的预设关系(n平面上任意一点变换前后应不发生变化, f平面上的中心点变换前后应不发生变化)，列出方程组： 可以解得A和B，得到最后的透视投影的转换矩阵$M_{persp-&gt;ortho}$","link":"/2020/12/10/Games101-Computer-Graphics-Week-4/"},{"title":"Games101: Computer Graphics-Week 5","text":"在依次进行了前面的步骤： Model transformation，将物体和摄像机放到标准位置； (M) View/Camera transformation，将摄像机角度到标准位置；(V) Projection Transformation，将被观测场景投影到标准的$[-1, 1]^{3}$范围后；(P) After MVP transformation，下一步就是将Projection画在屏幕上，这一步就是Rasterization(光栅化) ！ RasterizationPreview 回顾上节课的定义，定义一个立方体需要知道：$x$轴上$[l,r]$，$y$轴上$[b, t]$，$-z$轴上$[f, n]$，这里假设我们已经知道$f$和$n$平面，对于Perspetive Projection而言，需要定义视角锥。如下图所示，定义近平面需要两要素： Field-of-view(fovY，默认是垂直视角)：定义为两条横边中点的连线夹角，如图中两条红色虚线所示； Aspect ratio(宽高比)： $Aspect ratio = width/height$； 类似垂直视角，可以定义水平视角，此时为两条竖边的中点，并且当固定了宽高比和Fov后，即可求出水平视角。 用相机类比，Fov可以对应镜头的焦距所对应的视角； Canonical Cube to Screen 暂时不管$z$轴； 将MVP变换后的$[-1,1]^{2}$映射到$[0,width]\\times[0,height]$尺寸上； 如何实现？先scale再translate； 注意在上述操作中，这些操作都是对空间中的各种立方体操作的，如何将这些立方体打散到每个像素点，求解到每个像素点像素值，这个过程称为光栅化。 Different raster displays(光栅显示设备) Oscilloscope(示波器)，显示原理和早期显示器一致，阴极射线管发生电子打到荧光屏上，CRT(Cathode Ray Tube)，以扫描的形式进行画图呈像； Frame Buffer，现在显示认为就是内存或显存中的一部分空间，屏幕就是讲内存中的内容映射显示到物理设备上，包括： LCD(Liquid Crystal Display，液晶显示器)，利用液晶材料的极化作用，进行光线的扭转； LED(Light Emitting Diode，发光二极管)； Electronic Ink Display，电子墨水屏，刷新率很低； Triangles - Fundamental Shape Primitives 重心坐标插值-barycentric interpolation Rasterizing a triangle光栅化最核心的步骤： 左图三角形代表经过MVP，Projection变换后的图形，图中每一个方格代表一个像素，光栅化就是判断每一个点和三角形的关系并进行取值。 下面介绍一个最简单和最广泛使用的方法-**采样(Sample)**： 前提： 认为每个像素内部是不可分割，颜色一致的小块； 认为每个像素块的中心是$(x+0.5, y+0.5)$，由质心确定对应像素块的颜色； 这里用代码更容易说清楚： 1234for (int x=0; x&lt;xmax; ++x) for(int y=0; y&lt;ymax; ++y) // 这里的inside函数用以判断点是否在图形内侧，算法可参考前面的固定方向叉乘 image[x][y] = inside(tri, x+0.5, y+0.5);","link":"/2020/12/11/Games101-Computer-Graphics-Week-5/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Adjust Themes Icarus themes: url Icarus offical docs: url How to adjust themes: url","link":"/2020/12/02/hello-world/"}],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","link":"/tags/Computer-Graphics/"},{"name":"Summary","slug":"Summary","link":"/tags/Summary/"},{"name":"Linear algebra","slug":"Linear-algebra","link":"/tags/Linear-algebra/"},{"name":"Transformations","slug":"Transformations","link":"/tags/Transformations/"},{"name":"Rasterization","slug":"Rasterization","link":"/tags/Rasterization/"}],"categories":[{"name":"Computer Graphics","slug":"Computer-Graphics","link":"/categories/Computer-Graphics/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}]}